---
layout:     post   				    # 使用的布局（不需要改）
title:      虚函数				# 标题 
subtitle:   面向对象基础知识 #副标题
date:       2022-04-19 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 面向对象
    - 八股
---


# 虚函数

## 虚函数的一个定义

究竟为什么叫“虚函数”呢？它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在**运行时刻**被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被称为“虚”函数。

* virtual关键字只用在类定义里的函数声明中，类外面写函数体时不用；
* **构造函数**和**静态成员函数static**不能是虚函数。


## 定义纯虚函数的作用

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

```CPP
class A  
{  
public:  
    virtual void func()  
    {  
        cout<<"A::类的func()被调用"<<endl;  
    }  
};  
class B:public A  
{  
public:  
    void func()  
    {  
        cout<<"B::类的func()被调用"<<endl;  
    }  
};  
int main(void)  
{  
    A *a = new B();  
    a->func();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  因为只看a指向哪个类。
    return 0;  
}
```

## 纯虚函数

先看代码：

```CPP
class A
{
public:
    A();                //默认构造函数
    A(int a, int b);    //构造函数重载
    virtual void func() = 0;//纯虚函数
};
class B:public A
{
public:
    B();                //默认构造函数
    B(int a, int b);    //构造函数重载
    virtual void func() {cout << "类B的虚函数" << endl;}//这次就是单纯的虚函数
};
int main()
{
    A a;//会报错，抽象类不能有对象
    A *p;//父类指针是可以的。
    B b;//子类可以创建对象，没问题
    *p = &b;//父类指针指向b，没问题
    p->func();//通过多态来调用子类的func方法
    return 0;
}
```

* 纯虚函数只有声明，没有定义。纯虚函数的具体内容要靠**子类的多态**来实现。
* 当声明了纯虚函数后，这个A就自动变为了一个**抽象类**。因此可以理解为：抽象类和纯虚函数往往是绑定的！
* 抽象类依然可以创建A的指针，但这个时候不能再创建A的对象了(因为没有意义，对吧。一个学生只能是小学/初中/高中/大学中的一种，而不能是“学生”本身)。
* 

# 多态
* 多态的核心，就是只要在main函数的开始处设置一个父类的指针，之后这个指针就可以动态指向不同的类；并且指针还可以动态地调用不同的类的方法，从而实现了不同数据类使用相同的方法。而正常而言，父类指针只可以指向子类对象，却只能调用父类的各种函数。为什么可以调用呢？原因很简单——**虚函数**的存在。
* 对于同一个函数名的函数而言，**重载是编译时决定**，**多态是运行时决定**。在编译器看来，函数名相同而输入参数不同的函数就是两个完全不同的函数，因此编译器在编译阶段(Build阶段)就会选择合适的函数调用；而多态在编译时会一股脑把所有编译器认为相同的函数都写入内存中，形成一张**虚函数表**，之后需要调用哪个函数就从虚函数表中找出来。
