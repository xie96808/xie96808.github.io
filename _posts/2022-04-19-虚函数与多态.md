---
layout:     post   				    # 使用的布局（不需要改）
title:      虚函数				# 标题 
subtitle:   面向对象基础知识 #副标题
date:       2022-04-19 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 面向对象
    - 八股
---


# 一 虚函数

## 虚函数的一个定义

究竟为什么叫“虚函数”呢？它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在**运行时刻**被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被称为“虚”函数。

* virtual关键字只用在类定义里的函数声明中，类外面写函数体时不用；
* **构造函数**和**静态成员函数static**不能是虚函数。


## 定义纯虚函数的作用

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

```CPP
class A  
{  
public:  
    virtual void func()  
    {  
        cout<<"A::类的func()被调用"<<endl;  
    }  
};  
class B:public A  
{  
public:  
    void func()  
    {  
        cout<<"B::类的func()被调用"<<endl;  
    }  
};  
int main(void)  
{  
    A *a = new B();  
    a->func();   // 在这里，a虽然是指向A的指针，但是被调用的函数(func)却是B的!  因为只看a指向哪个类。
    return 0;  
}
```

## 纯虚函数

先看代码：

```CPP
class A
{
public:
    A();                //默认构造函数
    A(int a, int b);    //构造函数重载
    virtual void func() = 0;//纯虚函数
};
class B:public A
{
public:
    B();                //默认构造函数
    B(int a, int b);    //构造函数重载
    virtual void func() {cout << "类B的虚函数" << endl;}//这次就是单纯的虚函数
};
int main()
{
    A a;//会报错，抽象类不能有对象
    A *p;//父类指针是可以的。
    B b;//子类可以创建对象，没问题
    *p = &b;//父类指针指向b，没问题
    p->func();//通过多态来调用子类的func方法
    return 0;
}
```

* 纯虚函数只有声明，没有定义。纯虚函数的具体内容要靠**子类的多态**来实现。
* 当声明了纯虚函数后，这个A就自动变为了一个**抽象类**。因此可以理解为：抽象类和纯虚函数往往是绑定的！
* 抽象类依然可以创建A的指针，但这个时候不能再创建A的对象了(因为没有意义，对吧。一个学生只能是小学/初中/高中/大学中的一种，而不能是“学生”本身)。
* 

-------------------------------------------

# 二 内联函数

在函数声明或定义中函数返回类型前加上关键字inline即把min（）指定为内联。
```CPP
 inline int min(int first, int secend) {
    cout << "内联函数" << endl;
 }
```

* inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。而用户没有必要知道，也不应该知道函数是否需要内联。
* 与非inline函数不同的是，inline函数必须在调用该函数的**每个文本文件**中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。对于由两个文件A.CPP和B.CPP构成的程序来说，程序员不能定义这样的min()函数，它在 A.CPP 中指一件事情，而在 B.CPP 中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为.\
* 为保证不会发生这样的事情，建议把inline函数的定义**放到头文件**中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。

## 内联函数的声明与定义

* 定义在类声明之中的成员函数将**自动地**成为内联函数，但这样做并不是一种规范的编程风格.

```CPP
class A
{
public:
    void Foo(int x, int y) {  } // FOO在类声明内，自动地成为内联函数
};
```

良好的编程风格需要将函数的定义写在类的外面，甚至是.cpp文件：
```CPP
// 头文件
class A
{
public:
void Foo(int x, int y)；
}
// 定义文件
inline void A::Foo(int x, int y)
{
}
```

## 内联函数的优点和缺点

inline函数的优点是显而易见的——提高函数的执行效率。
在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。
如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。

既然内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数呢？
1.内联是以代码膨胀（复制）为代价，仅仅省去了**函数调用**的开销，从而提高函数的执行效率。如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收获会很少。(一般情况，在函数频繁调用且函数内部代码很少的情况下使用内联)
2.每一处内联函数的调用都要**复制代码**，将使程序的总代码量增大，消耗更多的内存空间。
3.以下情况不宜使用内联：
（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构
函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以**不要随便地将构造函数和析构函数的定义体放在类声明中**！

## inline函数和预处理的区别

1.这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。
2.C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。所以在C++程序中，应该用内联函数取代所有**表达式形式**的宏定义。

-------------------------------------------

# 三 多态
* 多态的核心，就是只要在main函数的开始处设置一个父类的指针，之后这个指针就可以动态指向不同的类；并且指针还可以动态地调用不同的类的方法，从而实现了不同数据类使用相同的方法。而正常而言，父类指针只可以指向子类对象，却只能调用父类的各种函数。为什么可以调用呢？原因很简单——**虚函数**的存在。
* 对于同一个函数名的函数而言，**重载是编译时决定**，**多态是运行时决定**。在编译器看来，函数名相同而输入参数不同的函数就是两个完全不同的函数，因此编译器在编译阶段(Build阶段)就会选择合适的函数调用；而多态在编译时会一股脑把所有编译器认为相同的函数都写入内存中，形成一张**虚函数表**，之后需要调用哪个函数就从虚函数表中找出来。
