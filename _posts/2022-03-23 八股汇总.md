---
layout:     post   				    # 使用的布局（不需要改）
title:      八股汇总 				# 标题 
subtitle:   计算机组成原理 | 计算机网络 | 底层代码逻辑 | 面向对象程序设计 | 设计模式 #副标题
date:       2022-03-22 				# 时间
author:     xie96808 						# 作者
header-img: img/sea1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 八股文
---

# 计算机组成原理 | 计算机网络 | 底层代码逻辑 | 面向对象程序设计 | 设计模式

## 计算机组成原理

### 如何理解中断？
中断是一种可以使CPU和硬件设备进行通信的技术。例如，当我们在敲击键盘时，键盘控制器（控制键盘的硬件设备）会发送一个中断，通知操作系统有键按下。从本质上说，中断是一种特殊的信号，由硬件设备向CPU发送。当CPU接收到中断信号后，就会马上通知操作系统此信号的到来，然后由操作系统负责处理这些新到来的数据。
中断的大致执行过程如下：
1. 引入中断是因为CPU某一时刻只能执行一项任务，为了协调多个任务的执行，引入了中断；
2. 每个任务都有他自己的工作地点和紧急程度，将工作地点写在中断向量表中，将紧急程度理解为中断优先级；
3. 当有中断发生时，首先查找中断向量表，找到报告中端的任务的地址，根据这个地址找到任务，最后根据其他因素决定要不要去执行这个任务。

根据中断源的不同，可把中断分为<strong>硬件中断</strong>和<strong>软件中断</strong>两大类。
1) 硬件中断，又可分为外部中断和内部中断。
硬中断共有5个中断，两个外部中断，两个定时/计数器中断，1个串口中断。对应的中断标号有0、1、2、3、4。其对应表示如下：
0 表示 外部中断INT0
1 表示 定时器中断T0
2 表示 外部中断INT1
3 表示 定时器中断T1
4 表示 串行中断
    这是一个很重要的标记，它规定着当前这个子函数是哪个中断源的中断服务子程序。
2) 软件中断，其实并不是真正的中断，它们只是可被调用执行的一般程序。
例如ROM BIOS中的各种外部设备管理中断服务程序（键盘管理中断，显示器管理中断）以及DOS的系统功能调用（INT 21H）等都是软件中断。


### 数组指针和指针数组的区别

* 数组指针
    定义数组指针（也称行指针）如下： 
```CPP
int (*p)[n];
```

圆括号()优先级高，首先说明p是一个<strong>指针</strong>，指向一个整型的一维数组。这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

如要将二维数组赋给一指针，应这样赋值：
```CPP
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
```
所以数组指针也称<strong>指向一维数组的指针</strong>，亦称行指针。

* 指针数组

定义指针数组如下：
```CPP
int *p[n];
```
中括号[]优先级高，先与p结合成为一个数组，再由int* 说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 * p=a; 这里 * p表示指针数组第一个元素的值，a的首地址的值。

如要将二维数组赋给一指针数组:
```CPP
int *p[3];
int a[3][4];
for(i=0;i<3;i++)
p[i]=a[i];
```

这里int * p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2], 所以要分别赋值。
这样两者的区别就豁然开朗了——数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。

还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。比如要表示数组中i行j列一个元素：* (p[i]+j)、*(*(p+i)+j)、(* (p+i))[j]、p[i][j]
优先级：()>[]>*

## 计算机网络

## 底层代码逻辑

### 各大关键字

#### Volatile关键字

* Volatile关键词的第一个特性：**易变性**。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。

* Volatile关键词的第二个特性：**不可优化性**。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。 

* Volatile关键词的第三个特性：**顺序性**。能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。 C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力 针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。

--------

#### const关键字

const名叫常量限定符，用来限定特定变量，以通知编译器该变量是**不可修改的**。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。

(1)const修饰基本数据类型

1.const修饰一般常量及数组

基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。

这也就意味着，**const int 和 int const的作用是相同的**。

2.const修饰指针变量* 及引用变量&

如果const位于星号* 的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；(const int* p = a; 此时a不变，但* p = c是可以的)

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。(int* const p = b; 此时* p是常量，即接下来再赋值* p = d会报错。) 

(2)const应用到函数中

1.作为参数的const修饰符

调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。 [注意]：参数const通常用于参数为指针或引用的情况;

2.作为函数返回值的const修饰符

声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。

(3)const在类中的用法

不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行 类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。

(4)const修饰类对象，定义常量对象 常量对象只能调用常量函数，别的成员函数都不能调用。

--------

#### static 关键字

控制变量的存储方式和可见性。

(1)修饰局部变量

一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

(2)修饰全局变量

对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。

(3)修饰函数

用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

(4)C++中的static

如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。

---------
#### extern关键字

在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是**在别处定义的**，要在此处引用”。

注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为**用extern会加速程序的编译过程**，这样能节省时间。

在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。

---------
#### typedef 和 #define的区别

1) **原理不同**  
    #define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。
    typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。
2) **功能不同**  
    typedef用来定义类型的别名，起到类型易于记忆的功能。另一个功能是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：typedef long double REAL， 在不支持long double的机器上，看起来是这样的——typedef double REAL，在不支持double的机器上是这样的——typedef float REAL
#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
3) **作用域不同**  
#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。

--------

#### C和C++的区别

详见之后的Blog [C和各大编程语言的对比与区别](https://github.com/xie96808/xie96808.github.io/blob/master/_posts/2022-04-08-(%E5%BE%85%E6%9B%B4%E6%96%B0)C%2B%2B%E4%B8%8E%E5%90%84%E5%A4%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94.md)

--------

#### strcpy，memset，memcpy的区别

** strcpy的作用是<strong>拷贝字符串</strong>，当它遇到'\0'时结束拷贝，原型为：extern char* strcpy(char* dest,char* src);  就是把后者src的字符串复制到前者dest中。

```CPP
#include<string.h>
#include<iostream.h>
void main(){
    char a[20],c[]="I am a teacher!";
    strcpy(a,c);
    cout<<a<<endl;
}
```
此小例子中，char c[]={'i',' ','a','m',' ', 'a', ' ', 't','e','a','c','h','e','r','\0'};字符串一般默认后面有一个结束符，

当用到strcpy(a,c);函数时，把c中的字符串复制到a中，当遇到字符串中默认的结束符后，复制结束。打印结果为  I am a teacher!

** memcpy用来做<strong>内存拷贝</strong>，可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；

原型函数为void* memcpy(void* dest, const void* src, size_t n);其中dest为返回的值。其功能为：从源src所指的内存地址的起始位置开始,拷贝n个字节到目标dest所指的内存地址的起始位置。

```CPP
int main()
{
    char *s="Golden Global View";//此字符串总共有18个字符，再加上一个结束符，总共存放19个字符
    char d1[20],d2[20];
    memcpy(d1,s,(strlen(s)+1));//用memcpy函数，把s中字符串的首地址拷贝到d中，连续复制19个字符

    memcpy(d2,s+14,5); //从第14个字符(V)开始复制，连续复制4个字符(View)
    printf("%d\n",strlen(s));
    printf("%s\n",d1);

    printf("%s\n",d2);
    return 0;
}
```
* memset的作用是对一段内存空间全部设置为某个字符，常用在<strong>内存空间的初始化</strong>，其原型函数为

void* memset(void* s,int c,size_t n);就是把已开辟内存空间s的首n个字节设置为c(c一般为0)。

```CPP
 int main()
 {
 char s[]="Golden State Worriors";
 memset(s,'G',6);//把s中的前6个字符改成G，也就是把Golden改成GGGGGG
 printf("%s\n",s);//输出为GGGGGG State Worriors
 return 0;
 }
```


## 面向对象程序设计

参考本文之后的Blog：

[构造函数与析构函数](https://github.com/xie96808/xie96808.github.io/blob/master/_posts/2022-04-05-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9.md)

[this指针](https://github.com/xie96808/xie96808.github.io/blob/master/_posts/2022-04-10-this%E6%8C%87%E9%92%88.md)

[静态成员变量与静态成员函数](https://github.com/xie96808/xie96808.github.io/blob/master/_posts/2022-04-11-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%26%E5%87%BD%E6%95%B0.md)

## 设计模式
