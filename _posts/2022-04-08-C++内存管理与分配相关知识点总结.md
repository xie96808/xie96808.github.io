---
layout:     post   				    # 使用的布局（不需要改）
title:      C++内存管理与分配相关知识点总结				# 标题 
subtitle:   八股的一部分 #副标题
date:       2022-04-08 				# 时间
author:     谢玄xx 						# 作者
header-img: img/bit (4).jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 内存分配
    - 八股
---

c++的指针：先在栈中存指针a，再向堆中申请内存空间存该指针所指向的元素，然后a指向该地址。

参考链接： [C/C++内存分配管理——作者HUST_Miao](https://blog.csdn.net/u010183728/article/details/81629706)

# 内存概述

在C++中内存分为5个区，分别是**堆**、**栈**、**自由存储区**、**全局/静态存储区**和**常量存储区**。

* **堆**：堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

* **栈**：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

* **自由存储区**：自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。

* **全局/静态存储区**：这块内存是在程序编译的时候就已经分配好的，在程序整个运行期间都存在。例如全局变量，静态变量。

* **常量存储区**：这是一块比较特殊的存储区，他们里面存放的是常量(const)，不允许修改。

---------

# 内存分配的方式

1. 静态存储区分配

内存在程序编译的时候就已分配好，这块内存在程序的整个运行空间内都存在，如**静态变量**，**全局变量**等。

2. 栈空间分配

程序在运行期间，函数内的局部变量通过栈空间(函数调用栈的方式)来分配存储。当函数执行完毕return时，栈空间就会被立即回收，如局部变量。

3. 堆空间分配

运行程序时，主要通过堆空间为其分配内存空间。通过malloc和new创建的对象都是从堆空间分配内存。这类空间则需要我们程序员自己管理，即用多少开多少，不用的时候及时释放掉。否则就可能会造成内存溢出的后果。

# 常见的内存错误及解决方法

1. 内存分配未成功，却使用了它。

   解决方法：在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。如果是用new来申请内存，申请失败是会抛出异常，所以应该捕捉异常来进行放错处理。

2. 内存分配虽然成功，但是尚未初始化就引用它。

   解决方法：尽管有时候缺省时会自动初始化，但是无论创建什么对象均要对其进行初始化，即便是赋零值也不可省略，不要嫌麻烦。

3. 内存分配成功，但越界访问。

　 解决方法：对数组for循环时要把握边界，否则可能会导致数组越界。

4. 忘记了释放内存，导致内存泄漏。

　 解决方法：动态内存的申请和释放必须配对，new-delete和malloc-free且使用次数必须相同。

# malloc关键字

* malloc()函数的头文件是stdlib.h，其函数声明如下：
     void* malloc(size_t size);
其中参数size_t size表示动态内存分配空间的大小，以字节为单位。

* size_t 是typedef重定义的类型，重定义这样数据类型的作用就是让使用者一目了然，指示使用者这个参数表示一个长度，在size后加上t，表示是整型相关数据类型的，以后看到xxx_t的类型，通常都是整型相关数据类型**重定义**。
在这里malloc()函数的返回值是一个指针，或者说是**分配后内存空间的首地址**。

* 如果malloc()函数申请空间成功则返回一段内存空间的首地址，失败则返回NULL。

# new与malloc的区别

提到内存分配，就不可避免地涉及new和malloc。

1. 申请的内存所在位置
new操作符从自由存储区（3）上为对象动态分配内存空间，而malloc函数从堆上（1）动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

特别地，new甚至可以不为对象分配内存！

2. 返回类型安全性
new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void* ，需要通过强制类型转换将void* 指针转换成我们需要的类型。
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。

3. 内存分配失败时的返回值
new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功.

4. 是否需要指定内存大小
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

5. 是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：
* 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
* 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
* 第三步：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：
* 第一步：调用对象的析构函数。
* 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

