---
layout:     post   				    # 使用的布局（不需要改）
title:      C++读取版图文件				# 标题 
subtitle:    #副标题
date:       2025-01-28 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea4.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 技术
---
# 一 GDSII
## 1 GDS文件结构
一个GDS文件由多个unit构成,下图为GDS文件结构。一个unit由length、type、record三部分构成。其中length为unsigned int,字节长度为2,代表一个unit的长度;type为unsigned int,字节长度为2,代表不同的记录类型;record可能为string、unsigned int、double等类型,字节长度为length-2-2,代表unit当中存放的数据。
![](https://raw.githubusercontent.com/xie96808/xie96808.github.io/master/img/2025-01-28-C++读取版图文件1.png)  
## 2 代码流程
### 2.1 GDS单线程读
1. 对待读取文件做分块内存映射,并使用QFuture创建内存管理线程用于后续异步释放内存;  
2. 对所需变量进行初始化操作。  
3. 读取当前位置的一个unit模块。   
4. 读取当前unit的length和type,若type为BGNSTR进入步6读取cell结构,否则进入步骤4;   
5. 判断type是否为ENDLIB,若不是则根据当前type对Database中的成员变量进行初始化。返回步骤3,否则进入步骤7;   
6. 读取当前cell信息   
6.1. 判断当前是否需要更换文件块,如果需要更换文件块时判断此文件块是否仍被使用,不被使用则通知内存管理线程释放该文件块;   
6.2. 读取当前unit的length和type,若type不属于element范围则进入步骤6.7,否则进入6.3进行element图素读取;  
6.3. 多次循环读取element中的相关属性,并进行图形类型赋值;  
6.4. 当前unit的type为ENDEL则表示当前elemen属性读取完毕;  
6.5. 将读取到的element信息和当前cell中已有的图素进行对比合并(若图素形状存在,则添加其相对位移,否则添加整个图素作为基本图素);  
6.6. 返回6.1读取新的element  
6.7. 当前unit的type不为ENDSTR时,则对当前cell的相关属性进行设置,循环返回6.1;  
6.8. 当前unit的type为ENDSTR时,退出读取循环,将所读取的element设置到当前cell中,并根据cell中的ref调用关系,完善celltree调用结构;  
6.9. 读cell结束,清理相关变量,返回步骤2。  
7. GDS单线程读结束,清理相关变量。  
### 2.2 GDS多线程读  
主线程:
1. 对待读取文件做分块内存映射,并使用QFuture创建内存管理线程用于后续异步释放内存;  
2. 对所需变量进行初始化操作。  
3. 读取当前unit的length和type,若type为BGNSTR进入步骤5,否则进入步骤4;   
4. 判断type是否为ENDLIB,若不是则根据当前type对Database中的成员变量进行初始化。返回步骤2,否则进入步骤6;   
5. 创建子线程用于读取当前cell信息,将该线程加入线程池,返回步骤2;   
6. 等待线程池内所有线程结束;  
7. GDS单线程读结束,清理相关变量。  

子线程:
1. 判断当前是否需要更换文件块,如果需要更换文件块时判断此文件块是否仍被使用,不被使用则通知内存管理   
2. 读取当前unit的length和type,若type不属于element范围则进入步骤7,否则进入3进行element图素读取;   
3. 多次循环读取element中的相关属性,并进行图形类型赋值;   
4. 当前unit的type为ENDEL则表示当前elemen属性读取完毕;  
5.将读取到的element信息和当前cell中已有的图素进行对比合并(若图素形状存在,则添加其相对位移,否则添加整个图素作为基本图素);   
6. 返回1读取新的element  
7.当前unit的type不为ENDSTR时,则对当前cell的相关属性进行设置,循环返回1;   
8.当前unit的type为ENDSTR时,退出读取循环,将所读取的element设置到当前cell中,并根据cell中的ref调用关系,完善celltree调用结构;   
9. 读cell结束,清理相关变量;  

### 2.3 GDS写
1.写入CDatabase中的相关属性信息;  
2.依次遍历cellmap进行cell的写入;   
2.1. 写入cell的相关属性信息;   
2.2.逐个写入当前cell各种element图素信息   
2.3. 写入cell尾信息;   
3.写入文件尾,写GDS结束。   
## 3 GDS读函数调用关系

![](https://raw.githubusercontent.com/xie96808/xie96808.github.io/master/img/2025-01-28-C++读取版图文件2.png)
![](https://raw.githubusercontent.com/xie96808/xie96808.github.io/master/img/2025-01-28-C++读取版图文件3.png)

# 二 OASII
## 1 文件结构
oas文件结构采用record作为基本组成结构,单个record由关键字(recordtype)和相应的数据格数组成,其长度不定。整体文件为双层结构,cell关键字为两层结构接口,因此读取采用如下方式。   
![](https://raw.githubusercontent.com/xie96808/xie96808.github.io/master/img/2025-01-28-C++读取版图文件4.png)   
## 2 具体流程   
### 2.1 OASI read   
1. 获得文件信息,得到文件分块内存映射指针。     
2. 读取START部分信息;    
3. 读取END部分信息,获得文件校验方式及校验结果;   
4. 全局变量初始化;   
5. 判断当前是否需要更换文件块;   
6. 读取当前record的recordtype,若recordtype为13,14(cell)则进入步骤8,若recordtype为2(END)则进入步骤10,否则进入步骤7;   
7. 读取cellname,textstring,layername等信息;进入步骤9;   
8. 读取cell部分信息;   
8.1. 创建OAS全局模态变量GModal,设置校验起始偏移;   
8.2. 读取cell模块头部信息;   
8.3. 判断当前是否需要更换文件块,并进行相应的cell段校验;   
8.4. 读取当前record的recordtype,若recordtype不属于cell层则进入8.8;   
8.5. 根据recordtype值不同,采用不同方式读取相应的element,并更新相关element的全局模态变量GModal信息;   
8.6. 将当前的element和当前cell中已读取的elements信息进行对比合并;   
8.7. 返回8.3循环读取相应的element;  
8.8. 计算cell的校验值并进行变量清空;返回步骤5; 
9. 校验当前record字段;    
10. 读取END部分信息,并进END模块校验,并检查校验结构与文件校验值是否一致;    
11. 完善cellname,textstring,text,cell等结构的相关信息;  
12. 构建layer索引。   
13. 清理相关变量结构,读取结束;  
    
### 2.2 OASIS Write  
1. 写入OAS START部分信息;      
2. 写入CELLNAME/TEXTSTRING双向索引中的等部分信息;   
3. 从内存中写入cell文件;  
3.1. 设置初始化全局模态变量;   
3.2. 写入cell文件头部信息,设置坐标模式;   
3.3. 依次将各种图素element的属性写入文件中,并实时更新全局模态变量;   
4. 写入END模块信息;   

参考资料:   
https://blog.csdn.net/uestc_huan/article/details/128510590?spm=1001.2014.3001.5502 OASIS解析第一部分   
https://blog.csdn.net/uestc_huan/article/details/128510661 OASIS解析第二部分    
