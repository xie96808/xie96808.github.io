---
layout:     post   				    # 使用的布局（不需要改）
title:      死锁现象与解决方法				# 标题 
subtitle:    #副标题
date:       2022-04-27 				# 时间
author:     谢玄xx 						# 作者
header-img: img/sea2.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 面向对象
    - 八股
---

# 前言

死锁现象多出现于Java开发环境，与本人所处的开发环境与开发状态相关度不高。但作为几乎必然会出现的开发现象，死锁相关知识点理应被重视。
当前本项目所涉及到类似“死锁”现象都集中于使三极管/MOSFET强制发一个高电平，之后电路就进入了平稳运行状态。这种处理方式是通过连接仿真器进行在线仿真，修改寄存器对应标志位来实现的。下面我们将关注在纯软件开发工作中(尤其是Java)，死锁现象的解释与可能的解决方案。

![死锁现象在实际生活中的表现——十字路口拥堵](https://raw.githubusercontent.com/xie96808/xie96808.github.io/master/img/sisuo.jpg)  

                                死锁现象在实际生活中的表现——十字路口拥堵

# 什么是死锁？

死锁（Deadlock）：是指**两个或两个以上的进程**在执行过程(申请资源)中，因**争夺资源**而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。称此时系统处于死锁状态或系统产生了死锁。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。我们称这些永远在**互相等待**的进程为死锁进程。

这句话的核心在于三处：
1. “两个或两个以上的进程”：也就是说死锁必定是在并发“进程”（这里的进程可以看作是一个泛指，具体要看这个系统是什么）间产生，单个进程不会产生死锁。  
2. “资源争夺”：这些并发的进程必须互相争夺资源，如果一个系统存在并发的进程，但是大家都井水不犯河水，那么也不会产生死锁。  
3. 造成的结果是这些进程进入一种状态，各个进程都无法继续推进，如果没有外力，这些进程无法跳出这个状态。

或许，死锁的最好例证是：Kansas 立法机构在 20 世纪初通过的一项法律，其中说道：“当两列列车在十字路口逼近时，它们应完全停下来，并且在一列列车开走之前另一列列车不能再次启动。”

# 产生死锁的必要条件

* 互斥条件：一个资源每次只能被一个进程使用。
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
* 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

# 死锁预防

* 破坏互斥条件——例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

* 破坏占有和等待条件——一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

* 破坏不可抢占条件

* 破坏环路等待——给资源统一编号，进程只能按编号顺序来请求资源。在我的项目中，破坏环路等待的方法就是SPI程序部分的switch case。通过case执行不同任务，从而避免资源申请过程中出现冲突。

# 如何处理死锁状态？

在系统设计、进程调度等方面注意如何不让上述四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源，这就是避免、预防和解决死锁的最佳实践。  
此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

一般来说，处理死锁问题有四种方法：
1. 通过协议来预防或避免死锁，确保系统不会进入死锁状态。
2. 可以允许系统进入死锁状态，然后检测它，并加以恢复。
3. 鸵鸟策略：不处理死锁，因为用户一般对产生死锁的体验低，且处理消耗资源高，发生概率低，所以不处理；
4. 利用杀死进程的方式，强制释放占用资源，使闭环消失。
